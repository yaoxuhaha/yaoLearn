https://www.cnblogs.com/dolphin0520/p/3920373.html

此前需要了解
1. 简单Thread实现



[toc]

---

# 一. 内存模型的相关概念

计算机在执行程序的时候,会涉及到许多读写操作,但是如果每次都从主存(物理内存)就会出现问题,cpu计算速度很快,但是读写操作会很慢,会大大降低执行速度.  

但是通过高速缓存的话,就可以避免大量通过主存的读写操作.而通过缓存对数据记性操作则非常快.

例子:

``` java
int i = 1;
int i = i + 1;
int j = i + 1;
```

将i读取到缓存中,然后cpu将i+1,再次存入高速缓存,直接将 缓存中的i给j赋值, 将缓存中的i j刷新到主存中.

---

但是在多线程中这样操作会出现问题.

我们预期 希望两个线程 都将i加一,使i=2,

但是也有可能会出现 线程1 将i=0取到缓存中执行加一操作  但是线程2也同时取i=0到自己的cpu缓存中执行加一操作, 这就会导致 刷新到主存之后,i的值还是1.

为了解决此问题有两种办法
1. 通过在总线加lock的方式(阻塞其他cpu访问)
2. 通过缓存一致性协议(在缓存中控制,使得共享变量达到一致)

# 2.并发编程中的三个概念

需要保证一下三个特性 才能保证并发编程的安全

　
想并发程序正确地执行，必须要保证原子性、可见性以及有序性

## 1.原子性

原子性：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。


最常遇到的 就是回滚操作解决这个问题

## 2.可见性

可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。

## 3.有序性
　有序性：即程序执行的顺序按照代码的先后顺序执行
　

# 3.java内存模型

在Java虚拟机规范中试图定义一种Java内存模型（Java Memory Model，JMM）来屏蔽各个硬件平台和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。

Java内存模型规定所有的变量都是存在主存当中（类似于前面说的物理内存），每个线程都有自己的工作内存（类似于前面的高速缓存）。线程对变量的所有操作都必须在工作内存中进行，而不能直接对主存进行操作。并且每个线程不能访问其他线程的工作内存。

## 1.原子性

在Java中，对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。

例子:

请分析以下哪些操作是原子性操作：

``` java
x = 10;         //语句1
y = x;         //语句2
x++;           //语句3
x = x + 1;     //语句4
```

咋一看，有些朋友可能会说上面的4个语句中的操作都是原子性操作。其实只有语句1是原子性操作，其他三个语句都不是原子性操作。

　　语句1是直接将数值10赋值给x，也就是说线程执行这个语句的会直接将数值10写入到工作内存中。

　　语句2实际上包含2个操作，它先要去读取x的值，再将x的值写入工作内存，虽然读取x的值以及 将x的值写入工作内存 这2个操作都是原子性操作，但是合起来就不是原子性操作了。

　　同样的，x++和 x = x+1包括3个操作：读取x的值，进行加1操作，写入新的值。

 　　所以上面4个语句只有语句1的操作具备原子性。

　　也就是说，只有简单的读取、赋值（而且必须是将数字赋值给某个变量，变量之间的相互赋值不是原子操作）才是原子操作。
　　
　　从上面可以看出，Java内存模型只保证了基本读取和赋值是原子性操作，如果要实现更大范围操作的原子性，可以通过synchronized和Lock来实现。由于synchronized和Lock能够保证任一时刻只有一个线程执行该代码块，那么自然就不存在原子性问题了，从而保证了原子性。

## 2.可见性
对于可见性，Java提供了volatile关键字来保证可见性。

　　当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。

　　而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。

　　另外，通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性
　　
## 3.有序性

java内存模型规定的部分顺序
1. 程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作
2. 锁定规则：一个unLock操作先行发生于后面对同一个锁额lock操作
3. volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作
4. 传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C
5. 线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作
线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生
6. 线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行
7. 对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始


　　这8条原则摘自《深入理解Java虚拟机》。

不符合以上规则的需要进行操控 
通过使用volitile 或者synchronized Lock.


